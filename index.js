
// Import modules generated by ANTLR.
var STIXPatternLexer = require( "./STIXPatternLexer" ).STIXPatternLexer;
var STIXPatternParser = require( "./STIXPatternParser" ).STIXPatternParser;
var antlr4 = require("antlr4");

/**
 * Modifies ErrorListener to collect error message and set flag
 * to False when an invalid pattern is encountered.
 */
class STIXPatternErrorListener extends antlr4.error.ErrorListener {
	constructor() {
		super();
		this.errStrings = [];
	}

	syntaxError(recogniser, offendingSymbol, line, column, msg, e) {
		this.errStrings.push(`FAIL: Error found at line ${line}:${column}. ${msg}`);
	}

}

function parsePattern( pattern ) {
	let start = pattern.slice(0, 2);

	var parseErrorListener = new STIXPatternErrorListener();
	var input = new antlr4.InputStream( pattern );
	var lexer = new STIXPatternLexer( input );
	// Remove any default listeners
	lexer.removeErrorListeners();
	
	let stream = new antlr4.CommonTokenStream( lexer );
	let parser = new STIXPatternParser( stream );
	parser.removeErrorListeners();
	parser.addErrorListener( parseErrorListener );

	// This cleans up potential error messages:
	// This is the same hack used in the OASIS Python STIX Validator
	for( let i in parser.literalNames ) {
		if ( parser.literalNames[i] == "<INVALID>" ) {
			parser.literalNames[i] = parser.symbolicNames[i];
		}
	}

	// Perform the parsing. Normally this would return a parse tree,
	// but we are only validating, so we don't care.
	parser.buildParseTrees = false;
	parser.pattern();

	// Collect errors
	if ( !( start[0] == "[" || start == "([" ) ) {
		// Give a much more sensible error message for this case.
		parseErrorListener.errStrings[0] = "FAIL: Error found at line 1:0. " +
		"input is missing square brackets";
	}

	return parseErrorListener.errStrings;

}

function validate( pattern ) {
	return parsePattern( pattern ).length == 0;
}

exports.parsePattern = parsePattern;
exports.validate = validate;